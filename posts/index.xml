<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Figaro ZP</title>
		<link>https://z-figaro.github.io/posts/</link>
		<description>Recent content in Posts on Figaro ZP</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>All rights by figaro zp.</copyright>
		<lastBuildDate>Wed, 03 Apr 2019 16:55:07 +0800</lastBuildDate>
		<atom:link href="https://z-figaro.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title> Attribute 实现系统代码提示</title>
			<link>https://z-figaro.github.io/posts/-attribute-%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA/</link>
			<pubDate>Wed, 03 Apr 2019 16:55:07 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/-attribute-%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA/</guid>
			<description>资料放在最前面，方便同学查询。 官方文档 matt大神 attribute是GNU C特色之一,在iOS用的比较广泛.系统中有许多地方使用到. att</description>
			<content type="html"><![CDATA[

<p><a href="http://releases.llvm.org/3.8.0/tools/clang/docs/AttributeReference.html#opencl-address-spaces" target="_blank">资料</a>放在最前面，方便同学查询。
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html" target="_blank">官方文档</a>
<a href="https://nshipster.com/__attribute__/" target="_blank">matt大神</a></p>

<p>attribute是GNU C特色之一,在iOS用的比较广泛.系统中有许多地方使用到. attribute可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.</p>

<h2 id="函数属性-function-attribute">函数属性(Function Attribute)</h2>

<ul>
<li>noreturn</li>
<li>noinline</li>
<li>always_inline</li>
<li>pure</li>
<li>const</li>
<li>nothrow</li>
<li>sentinel</li>
<li>format</li>
<li>format_arg</li>
<li>no_instrument_function</li>
<li>section</li>
<li>constructor</li>
<li>destructor</li>
<li>used</li>
<li>unused</li>
<li>deprecated</li>
<li>weak</li>
<li>malloc</li>
<li>alias</li>
<li>warn_unused_result</li>
<li>nonnull</li>
</ul>

<h2 id="类型属性-type-attributes">类型属性(Type Attributes)</h2>

<ul>
<li>aligned</li>
<li>packed</li>
<li>transparent_union,</li>
<li>unused,</li>
<li>deprecated</li>
<li>may_alias</li>
</ul>

<h2 id="变量属性-variable-attribute">变量属性(Variable Attribute)</h2>

<ul>
<li>aligned</li>
<li>packed</li>
</ul>

<h2 id="clang特有的">Clang特有的</h2>

<ul>
<li>availability</li>
<li>overloadable</li>
</ul>

<p>以上是我抄录的，并不只有这些。</p>

<h1 id="书写格式">书写格式</h1>

<p>书写格式：attribute后面会紧跟两对原括弧，括弧里面是相应的attribute参数</p>

<pre><code>__attribute__((xxx))
</code></pre>

<h2 id="使用场景和技巧">使用场景和技巧</h2>

<p>系统使用了宏定义封装了很多，建议遇到或者需要使用的特意记录一下。毕竟真的很多很多，你也不太常用的。
其中我整理了一下比较常用的一些参数，转录了很多不同作者总结的，站在巨人的肩膀上；边走边抄。</p>

<h3 id="更新了-之前的废弃">更新了，之前的废弃</h3>

<pre><code>//可以自定义描述信息
__attribute__((deprecated(&quot;已过期!&quot;)))

//系统的宏定义
DEPRECATED_ATTRIBUTE 
</code></pre>

<p>我们经常看到三方或者系统中，有的方法废弃了。比如alertview，那么我们就应该这样写。</p>

<pre><code>//标记这个属性已过期
@property (nonatomic, strong) NSString *name __attribute__((deprecated(&quot;属性已过期&quot;)));

//标记方法已过期
- (void) testOld __attribute__((deprecated(&quot;方法已过期, 请使用 test2&quot;))) {  
}

- (void) testNew {
}

-(void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];

    //编译器警告，'testOld' is deprecated: 已过期, 请使用 testNew
    [self testOld];

    //编译器警告，提示 &quot;'name' 已过期...&quot;
    NSLog(@&quot;%@&quot;, self.name);
}
</code></pre>

<h3 id="更新了-不能用">更新了，不能用</h3>

<pre><code>//可以自定义描述信息
__attribute__((unavailable(&quot;已经废弃,请使用 xxxx&quot;)))


//系统宏定义
NS_UNAVAILABLE;
UNAVAILABLE_ATTRIBUTE;
</code></pre>

<p>使用场景：</p>

<ul>
<li>自定义了类的初始化方法，不希望外界使用初始化初始化，并且给出正确的提示。比如单例不能使用init方法，应该用自定义的初始化方法。</li>
<li>比希望继续使用某个属性，并且给出正确的提示。</li>
</ul>

<pre><code>@interface ViewController : UIViewController
@property (nonatomic, strong) NSString *name __attribute__((unavailable(&quot;这个属性已经废弃&quot;)));

#pragma mark - 初始化
-(instancetype)init __attribute__((unavailable(&quot;这个方法已经废弃,请使用 initWithName:&quot;)));

-(instancetype)initWithName:(NSString *)Name;
@end

//测试方法

- (void) test {
    //编译不通过，提示 &quot;'init' 已经废弃了...&quot;
    ViewController *vc = [[ViewController alloc] init];

    //编译不通过，提示 &quot;'name' 已经废弃了...&quot;
    NSLog(@&quot;%@&quot;, vc.name);
}
</code></pre>

<h3 id="block中提示self可能引起循环引用">block中提示self可能引起循环引用</h3>

<pre><code>__attribute__((ns_consumes_self))

//系统宏定义
NS_REPLACES_RECEIVER

//系统的封装
#if __has_feature(attribute_ns_consumes_self)
#define NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED
#else
#define NS_REPLACES_RECEIVER
#endif
</code></pre>

<p>这是我在一些组件功能的时候，发现别人会提示在block中需要注意的。</p>

<pre><code>-(NSString *)stringManager:(stringBlock) resultString NS_REPLACES_RECEIVER;

它只能在方法中使用
self.subString = ^NSString *(NSString *string) {
        //这里就是弹警告
        [self testOld];
        NSLog(@&quot;string -- %@&quot;,string);
        return [string substringFromIndex:1];
    };
</code></pre>

<h3 id="在哪些平台或者版本可用">在哪些平台或者版本可用</h3>

<pre><code>__attribute__((availability(ios,introduced=6.0,deprecated=8.0,obsoleted=10.0,message=&quot;ios10.0中废弃&quot;)));

ios：iOS平台
introduced：开始使用的版本
deprecated：开始弃用的版本
obsoleted：禁止使用的版本

只能在方法中使用
</code></pre>

<h3 id="变量的作用域结束时-调用指定的函数">变量的作用域结束时，调用指定的函数</h3>

<pre><code>__attribute__((cleanup(作用域结束调用的函数名)))
</code></pre>

<pre><code>void intCleanup(int *value){
    NSLog(@&quot;cleanup:%d&quot;,*value);
}

void stringCleanup(__strong NSString **value){
    NSLog(@&quot;cleanup:%@&quot;,*value);
}

void rectCleanup(CGRect *value){
    CGRect temp = *value;
    NSString *str = NSStringFromCGRect(temp);
    NSLog(@&quot;cleanup:%@&quot;,str);
}

void appDelegateCleanup(__strong AppDelegate **value){
    NSLog(@&quot;cleanup:%@&quot;,*value);
}

int main(int argc, char * argv[]) {
    //第一个作用域
    {
        int a __attribute__((cleanup(intCleanup))) = 10;
    }
    //第二个作用域
    {
        NSString *string __attribute__((cleanup(stringCleanup))) = @&quot;张三&quot;;
        CGRect rect __attribute__((cleanup(rectCleanup))) = {0,0,1,1};
    }
    //第三个作用域
    {
        AppDelegate *delegate __attribute__((cleanup(appDelegateCleanup))) = [[AppDelegate alloc] init];
    }
}


//控制台输出
1.xxx[6549:886516] cleanup:10
2.xxx[6549:886516] cleanup:{{0, 0}, {1, 1}}
3.xxx[6549:886516] cleanup:张三 //用一个作用域，这一个cleanup 是最先加的
4.xxx[6780:893605] cleanup:&lt;AppDelegate: 0x6040000337a0&gt;
5.xxx[6780:893605] AppDelegate dealloc //dealloc 在 cleanup之后
</code></pre>

<p>别人的总结：</p>

<pre><code>1.一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序
2.调用时机：cleanup比dealloc早
3.作用域的结束包括:大括号结束、return、goto、break、exception等
</code></pre>

<p>所以我感觉可以控制作用域和代码执行顺序：</p>

<pre><code>//指向block的指针,觉得不好理解可以用typeof
void blockCleanUp(void(^*block)()){
    (*block)();
}

 void (^block)(void) __attribute__((cleanup(blockCleanUp))) = ^{
        NSLog(@&quot;finish block&quot;);
    };

</code></pre>

<p>这个好处就是,不用等到block最后才写某些代码,我们可以把它放在block的任意位置,防止忘记.</p>

<p>参考：<a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/#rd" target="_blank">黑魔法</a></p>

<h3 id="一个类不能有子类">一个类不能有子类</h3>

<p>使用与类，该类不能有子类</p>

<pre><code>__attribute__((objc_subclassing_restricted))
</code></pre>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

__attribute__((objc_subclassing_restricted))
@interface KDClangTest : NSObject
@end


#import &quot;KDClangTest.h&quot;

//这里编译出错，提示“Cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute”
@interface KDClangSonTest : KDClangTest
@end

</code></pre>

<h3 id="子类要重写某个方法-必须调用super">子类要重写某个方法，必须调用super</h3>

<pre><code>//通用写法
__attribute__((objc_requires_super))

//系统宏定义，其实和上面是一样的
NS_REQUIRES_SUPER

</code></pre>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface KDClangTest : NSObject

- (void)instanceMethod1 __attribute__((objc_requires_super));
@end


#import &quot;KDClangTest.h&quot;

@interface KDClangSonTest : KDClangTest
@end
@implementation KDClangSonTest


-(void)instanceMethod1 {
    NSLog(@&quot;I am son&quot;);
    //这里编译器会出现警告： Method possibly missing a [super instanceMethod1] call
}
</code></pre>

<h3 id="在函数某个参数不能为空">在函数某个参数不能为空</h3>

<pre><code>__attribute__((nonnull (x)))
</code></pre>

<pre><code>- (int)addNum1:(int *)num1 num2:(int *)num2  __attribute__((nonnull (1,2))){//1,2表示第一个和第二个参数不能为空
    return  *num1 + *num2;
}

- (NSString *)getHost:(NSURL *)url __attribute__((nonnull (1))){//第一个参数不能为空
    return url.host;
}
</code></pre>

<h3 id="类或协议的名字在编译时指定成另一个">类或协议的名字在编译时指定成另一个</h3>

<pre><code>__attribute__((objc_runtime_name(&quot;xxx&quot;)))
</code></pre>

<pre><code>在编译时指定成另一个.示例如下:
__attribute__((objc_runtime_name(&quot;NSObject&quot;)))
@interface SGObject :NSObject

@end

 //调用
 NSLog(@&quot;%@&quot;,[SGObject class]);
 //输出
 2016-07-22 11:18:00.934 Study[14355:5516261] NSObject

</code></pre>

<p>很有很多<a href="https://medium.com/@liushuaikobe/%E4%B8%8Eclang%E5%85%B1%E8%88%9E-attribute-8b6bc839958c" target="_blank">例子</a>
<a href="https://www.jianshu.com/p/29eb7b5c8b2d" target="_blank">很多很多</a></p>
]]></content>
		</item>
		
		<item>
			<title>Block使用详解</title>
			<link>https://z-figaro.github.io/posts/block%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</link>
			<pubDate>Tue, 02 Apr 2019 11:26:34 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/block%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</guid>
			<description>Block本质 通过LLVM的编译器-rt子项目存储库中找到runtime下的Block源码 struct Block_layout { void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */ }; 我们实现</description>
			<content type="html"><![CDATA[

<h1 id="block本质">Block本质</h1>

<p>通过<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/" target="_blank">LLVM的编译器-rt子项目存储库</a>中找到runtime下的Block源码</p>

<pre><code>struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>

<p>我们实现一个block，就是实现了这个结构体，isa指向block具体的类，invoke函数对应oc中代码的具体实现，所以block是oc的对象。
因为block是一个对象，所以它可以作为一个参数来传递，也可以作为一种属性来操作，它本身也像一个闭包函数。所以block基本上就变成了一把瑞士军刀，它可以极大的简化代码，并且结构紧凑。你每天一定在不停的使用block。那么让我们来彻底掌握block的原理，使用方法，和注意事项。</p>

<h1 id="block的使用">Block的使用：</h1>

<p>block可以简化代码，并且实现链式，函数式编程。因为它可以返回，传递它本身。
如果有一套操作链，那么最好用block封装好一系列操作步骤。</p>

<h2 id="block-的声明">block 的声明</h2>

<p>block的书写规则比较难写：</p>

<p>作为局部变量</p>

<blockquote>
<p>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {&hellip;};</p>
</blockquote>

<p>作为属性（property）
&gt; @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</p>

<p>定义方法时，作为方法参数</p>

<blockquote>
<p>-(void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</p>
</blockquote>

<p>调用方法时，作为参数传递
&gt; [someObject someMethodThatTakesABlock:^returnType (parameters) {&hellip;}];</p>

<p>作为类型别名 （typedef），增加代码可读性
&gt; typedef returnType (^TypeName)(parameterTypes);
&gt; TypeName blockName = ^returnType(parameters) {&hellip;};</p>

<p>这里我们强烈建议按照最后一种方式typedef方式书写，可以极大的提高代码可读性。</p>

<p>这里按顺序展示block的使用：
声明：</p>

<pre><code>void(^blockName)(NSString * str,BOOL success);
 //省略参数的写法：void(^blockName1)(NSString *,BOOL);
</code></pre>

<p>block的调用：</p>

<pre><code>blockName(@&quot;bwrgrets&quot;,YES);
</code></pre>

<p>block的实现：</p>

<pre><code>blockName = ^(NSString * str,BOOL success){
        //block的实现部分，block体
        //声明和赋值时，block体中的代码都不会执行
        NSLog(@&quot;执行blokc体中的代码&quot;);
    };
</code></pre>

<h2 id="block-修饰局部变量">__block 修饰局部变量</h2>

<p>说截获自动变量之前我们先看以下代码</p>

<pre><code>int tmp = 2;
int (^blk) (int) = ^(int count){
    return count+tmp;
};
tmp = 3;
int result = blk(2);
NSLog(@&quot;%d&quot;,result);
</code></pre>

<p>以上代码会打印出多少呢？5还是4？？ 正确答案是4
为什么是4呢？其实就是因为Block截获自动变量的原因</p>

<pre><code>struct __ViewController__viewDidLoad_block_impl_0 {
  struct __block_impl impl;
  struct __ViewController__viewDidLoad_block_desc_0* Desc;
  int tmp;
  __ViewController__viewDidLoad_block_impl_0(void *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, int _tmp, int flags=0) : tmp(_tmp) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static int __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, int count) {
  int tmp = __cself-&gt;tmp; // bound by copy

        return count+tmp;
    }

static struct __ViewController__viewDidLoad_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __ViewController__viewDidLoad_block_desc_0_DATA = { 0, sizeof(struct __ViewController__viewDidLoad_block_impl_0)};

static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) {
    ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}, sel_registerName(&quot;viewDidLoad&quot;));
    int tmp = 2;
    int (*blk) (int) = ((int (*)(int))&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, tmp));
    tmp = 3;
    int result = ((int (*)(__block_impl *, int))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, 2);
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_6n_mdf6rn0d5f5cw6r1h2620h3w0000gn_T_ViewController_b80e84_mi_0,result);
}`__ViewController__viewDidLoad_block_impl_0`

</code></pre>

<p>通过以上代码可以看出,当我们在给Block类型变量赋值的时候，tmp变量同时被传入，并且被保存到了<strong>ViewController</strong>viewDidLoad_block_impl_0的struct中。这时候其实就是截获了自动变量，由于已经在struct类中保存了一份，即使后边更改，也不会影响Block截获的值。</p>

<pre><code>int (*blk) (int) = ((int (*)(int))&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, tmp));
</code></pre>

<p>为什么要对局部变量进行截获呢？而全局变量和静态变量不需要截获，并且修改的的时候也不需要加__block呢？</p>

<p>主要原因就是<strong>变量的生命周期</strong>。局部变量在代码块执行结束之后就会被释放，但是Block不一定在此时释放。所以就会出现变量超过生命周期的现象，此时对局部变量进行截获，即使局部变量被释放，但是Block同样还是可以正常使用的。因为全局变量和静态变量的释放时间肯定不会在Block之前，所以不必对他们进行截获。</p>

<blockquote>
<p>全局变量和静态变量存储在全局数据区；局部变量存储在栈中。
不知道大家有没有想过一个问题，为什么需要<strong>block呢？如果没有</strong>block难道就修改不了变量了吗？</p>
</blockquote>

<p>我们先看一下加了__block编译器给我们做了啥</p>

<pre><code>struct __Block_byref_tmpBlock_0 {
  void *__isa;
__Block_byref_tmpBlock_0 *__forwarding;
 int __flags;
 int __size;
 int tmpBlock;
};

struct __ViewController__viewDidLoad_block_impl_0 {
  struct __block_impl impl;
  struct __ViewController__viewDidLoad_block_desc_0* Desc;
  __Block_byref_tmpBlock_0 *tmpBlock; // by ref
  __ViewController__viewDidLoad_block_impl_0(void *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, __Block_byref_tmpBlock_0 *_tmpBlock, int flags=0) : tmpBlock(_tmpBlock-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static int __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself, int count) {
  __Block_byref_tmpBlock_0 *tmpBlock = __cself-&gt;tmpBlock; // bound by ref

        (tmpBlock-&gt;__forwarding-&gt;tmpBlock) = 100;
        return count+(tmpBlock-&gt;__forwarding-&gt;tmpBlock);
    }
static void __ViewController__viewDidLoad_block_copy_0(struct __ViewController__viewDidLoad_block_impl_0*dst, struct __ViewController__viewDidLoad_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;tmpBlock, (void*)src-&gt;tmpBlock, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __ViewController__viewDidLoad_block_dispose_0(struct __ViewController__viewDidLoad_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;tmpBlock, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __ViewController__viewDidLoad_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __ViewController__viewDidLoad_block_impl_0*, struct __ViewController__viewDidLoad_block_impl_0*);
  void (*dispose)(struct __ViewController__viewDidLoad_block_impl_0*);
} __ViewController__viewDidLoad_block_desc_0_DATA = { 0, sizeof(struct __ViewController__viewDidLoad_block_impl_0), __ViewController__viewDidLoad_block_copy_0, __ViewController__viewDidLoad_block_dispose_0};

static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) {
    ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}, sel_registerName(&quot;viewDidLoad&quot;));
    __attribute__((__blocks__(byref))) __Block_byref_tmpBlock_0 tmpBlock = {(void*)0,(__Block_byref_tmpBlock_0 *)&amp;tmpBlock, 0, sizeof(__Block_byref_tmpBlock_0), 2};
    int (*blk) (int) = ((int (*)(int))&amp;__ViewController__viewDidLoad_block_impl_0((void *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, (__Block_byref_tmpBlock_0 *)&amp;tmpBlock, 570425344));
    int result = ((int (*)(__block_impl *, int))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, 2);
    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_6n_mdf6rn0d5f5cw6r1h2620h3w0000gn_T_ViewController_a1c583_mi_0,result);
}

</code></pre>

<p>这时候大家可以与前边没有加<strong>block的代码进行比较，两者的差别在哪里。 其实大家应该很容易发现加了</strong>block之后，变量形成了一个struct，这个struct中保存了变量的值，同时还有一个<strong>forwarding。这个</strong>forwarding其实就是为什么需要__block的关键。</p>

<p>Block从栈复制到堆的时候，__block变量也会受到影响。如下:</p>

<table>
<thead>
<tr>
<th>__block变量的配置存储域</th>
<th>Block从栈到堆时的影响</th>
</tr>
</thead>

<tbody>
<tr>
<td>栈</td>
<td>从栈复制到堆并被Block持有</td>
</tr>

<tr>
<td>堆</td>
<td>被Block持有</td>
</tr>
</tbody>
</table>

<p>ARC下，Block如果是栈的话，默认会copy到堆上。此时所使用的__block变量同时也会从栈被复制到堆上如下图</p>

<p><img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190403145037.png?token=ANanysxB8RtkCal3Zzl19dfrzf0Q5Mx9ks5cpFgKwA%3D%3D" alt="" /></p>

<p>那如果Block在堆上了，我们在Block中修改了变量，怎么让栈上的变量也同时能正确访问呢？这其实就是__forwarding功劳了。</p>

<p><strong>block变量初始化的时候</strong>forwarding是指向本身自己的。当<strong>block变量从栈复制到堆上的时候，此时会将</strong>forwarding的值替换为复制到目标堆上的__block变量用结构体实例的地址。如下图：</p>

<p><img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190403144858.png?token=ANanyrYm0e7R6XKH9fyEwvL8f4-ihE5tks5cpFecwA%3D%3D" alt="" /></p>

<p>通过此功能，无论是在Block语法中、Block语法外使用<strong>block变量，还是</strong>block变量配置在栈上或堆上，都可以顺利地访问一个<strong>block变量。 到这里大家应该明白了&rdquo;</strong>block加了之后，是把变量的地址传入Block&rdquo;的说法是很片面的吧啦</p>

<h2 id="block为什么用copy修饰">block为什么用copy修饰</h2>

<blockquote>
<p>栈是吃了吐 堆是吃了拉</p>
</blockquote>

<p>默认情况下，block会存档在栈中(栈是吃了吐)，所以block会在函数调用结束被销毁，在调用会报空指针异常，如果用copy修饰的话，可以使其保存在堆区(堆是吃了拉) ，它的生命周期会随着对象的销毁而结束的。只要对象不销毁，我们就可以调用在堆中的block。
有时候，你会发现你用了strong也不会有任何问题，其实就是符合某些条件而已。官方建议copy修饰。</p>

<p>block有三种：</p>

<ol>
<li>全局block</li>
<li>堆block</li>
<li>栈block</li>
</ol>

<p>这里先不展开讲，以后慢慢补充。</p>

<h2 id="blockskit-大神示范block可以做什么">BlocksKit 大神示范block可以做什么</h2>

<p>这里就有非常非常多，可以学习的地方了。当你以为搞懂了block的时候，你可以仔细看看这个三方库，这里会教你做人。</p>

<p>这里有篇<a href="https://blog.csdn.net/ZeroOnet/article/details/77159789" target="_blank">文章</a>对BlocksKit有一定的分析，可以先看看。之后我也会慢慢做源码分析和做一些实际的项目。</p>
]]></content>
		</item>
		
		<item>
			<title>Xcode中如何使用断点</title>
			<link>https://z-figaro.github.io/posts/xcode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%AD%E7%82%B9/</link>
			<pubDate>Thu, 21 Mar 2019 13:34:06 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/xcode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%96%AD%E7%82%B9/</guid>
			<description>断点调试 断点使用是我们开发提高效率，解决问题的不二法门；能够清楚的使用断点调试技巧，是基本技能。 edit breakpoint 编辑断点 reveal in breakpoint navigator 断点导航器 这就是我们的两</description>
			<content type="html"><![CDATA[

<h1 id="断点调试">断点调试</h1>

<p>断点使用是我们开发提高效率，解决问题的不二法门；能够清楚的使用断点调试技巧，是基本技能。</p>

<p><img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190321152623.png?token=ANanygXSAT9Zqbl4xpwd_xtaZQBoj6Hdks5ckzziwA%3D%3D" alt="" /></p>

<ul>
<li>edit breakpoint 编辑断点</li>
<li>reveal in breakpoint navigator 断点导航器</li>
</ul>

<p>这就是我们的两个武器。</p>

<h2 id="edit-breakpoint">Edit Breakpoint</h2>

<p>是编辑断点信息，点击之后是：
<img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190321152717.png?token=ANanyhxVEzBNmR0bNakNse7ofsMgd6bGks5ckz0XwA%3D%3D" alt="" /></p>

<ul>
<li><p>condition</p>

<p>顾名思义，这是断点生效的条件。
不能够识别：</p>

<ol>
<li>断点之外作用域的变量，函数</li>
<li>预处理的宏定义</li>
</ol></li>

<li><p>ignore</p>

<p>忽略次数，该断点生效几次之后才执行。</p></li>

<li><p>action</p>

<p>重点：断点生效之后。执行什么操作。提供了6种方案。</p>

<ol>
<li><a href="https://blog.csdn.net/yang3wei/article/details/7964226" target="_blank">applescript</a> 执行脚本</li>
<li>Capture GPU Frame 捕获GPU当前所绘制的帧。该功能是辅助图形调试的</li>
<li>Debugger Command  让断点执行LLDB调试命令，例如 po xxx</li>
<li>Log Message 生成信息，和nslog很像</li>
<li>Shell Command 执行一个命令文件和参数列表</li>
<li>Sound  发出制定的声音
<br /></li>
</ol></li>

<li><p>options
直接执行不停顿，返回action的结果。</p></li>
</ul>

<p>接下来说明了概念就来实际操作：
<img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190321152745.png?token=ANanyiNEVogkBvALzhsx2axsclHm2apVks5ckz00wA%3D%3D" alt="" /></p>

<p>中间就是脚本语言写的内容，所以你可以写一套专门用来描述你这个断点要展示的信息的专用弹框。</p>

<p>其中右侧显示的
&gt; @expression@ = LLDB表达式
&gt; %B = 断点的名称
&gt; %H = 遇到该断点的次数</p>

<p>使用好这些信息将会很酷，&rdquo;Your breakpoint %B has been hit %H times&rdquo;
试试把这短话放到图示哪里。</p>

<p><img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-21%20%E4%B8%8B%E5%8D%883.48.10.png?token=ANanym9lEcifSqOfjbAnGI4Bg_R_NbQ0ks5ck0J2wA%3D%3D" alt="" /></p>

<p>如此，你可以得到一些总结性的调试信息。</p>

<p>然后是最常用的 debugger command，这里使用的语句和在调试台使用的一模一样，如果不清楚可以看<a href="https://southpeak.github.io/2015/01/25/tool-lldb/" target="_blank">这里</a>。<strong>强烈建议阅读</strong></p>

<p>常用的如：</p>

<p>print xxx 显示全部信息
po  xxx   显示变量的值
exp a = xxx  改变 a的值，同时在代码和调试中生效
image使用：</p>

<pre><code>2015-01-25 14:12:01.007 test[18122:76474] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]'
*** First throw call stack:
(
	0   CoreFoundation                      0x00007fff8e06f66c __exceptionPreprocess + 172
	1   libobjc.A.dylib                     0x00007fff886ad76e objc_exception_throw + 43
	2   CoreFoundation                      0x00007fff8df487de -[__NSArrayI objectAtIndex:] + 190
	3   test                                0x0000000100000de0 main + 384
	4   libdyld.dylib                       0x00007fff8f1b65c9 start + 1
)
libc++abi.dylib: terminating with uncaught exception of type NSException

</code></pre>

<p>使用 image lookup定位错误 test具体的代码行数：
image lookup &ndash;address</p>

<pre><code>
(lldb) image lookup --address 0x0000000100000de0
      Address: test[0x0000000100000de0] (test.__TEXT.__text + 384)
      Summary: test`main + 384 at main.m:23
</code></pre>

<p>image lookup &ndash;type 查看具体类型</p>

<pre><code>(lldb) image lookup --type NSURL
Best match found in /Users/**/Library/Developer/Xcode/DerivedData/test-byjqwkhxixddxudlnvqhrfughkra/Build/Products/Debug/test:
id = {0x100000157}, name = &quot;NSURL&quot;, byte-size = 40, decl = NSURL.h:17, clang_type = &quot;@interface NSURL : NSObject{
    NSString * _urlString;
    NSURL * _baseURL;
    void * _clients;
    void * _reserved;
}
@property ( readonly,getter = absoluteString,setter = &lt;null selector&gt;,nonatomic ) NSString * absoluteString;
@property ( readonly,getter = relativeString,setter = &lt;null selector&gt;,nonatomic ) NSString * relativeString;
@property ( readonly,getter = baseURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * baseURL;
@property ( readonly,getter = absoluteURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * absoluteURL;
@property ( readonly,getter = scheme,setter = &lt;null selector&gt;,nonatomic ) NSString * scheme;
@property ( readonly,getter = resourceSpecifier,setter = &lt;null selector&gt;,nonatomic ) NSString * resourceSpecifier;
@property ( readonly,getter = host,setter = &lt;null selector&gt;,nonatomic ) NSString * host;
@property ( readonly,getter = port,setter = &lt;null selector&gt;,nonatomic ) NSNumber * port;
@property ( readonly,getter = user,setter = &lt;null selector&gt;,nonatomic ) NSString * user;
@property ( readonly,getter = password,setter = &lt;null selector&gt;,nonatomic ) NSString * password;
@property ( readonly,getter = path,setter = &lt;null selector&gt;,nonatomic ) NSString * path;
@property ( readonly,getter = fragment,setter = &lt;null selector&gt;,nonatomic ) NSString * fragment;
@property ( readonly,getter = parameterString,setter = &lt;null selector&gt;,nonatomic ) NSString * parameterString;
@property ( readonly,getter = query,setter = &lt;null selector&gt;,nonatomic ) NSString * query;
@property ( readonly,getter = relativePath,setter = &lt;null selector&gt;,nonatomic ) NSString * relativePath;
@property ( readonly,getter = fileSystemRepresentation,setter = &lt;null selector&gt; ) const char * fileSystemRepresentation;
@property ( readonly,getter = isFileURL,setter = &lt;null selector&gt;,readwrite ) BOOL fileURL;
@property ( readonly,getter = standardizedURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * standardizedURL;
@property ( readonly,getter = filePathURL,setter = &lt;null selector&gt;,nonatomic ) NSURL * filePathURL;
@end&quot;
</code></pre>

<h2 id="断点类型">断点类型</h2>

<h3 id="异常断点">异常断点</h3>

<p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。
<img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190321161608.png?token=ANanysOjcF-bA53iW8LXYC7l4o6viNlAks5ck0iJwA%3D%3D" alt="" /></p>

<p><strong>Exception</strong>
选择响应Objective－C对象抛出的异常，也可以选择响应C++对象抛出的异常。</p>

<p><strong>Break</strong>
选择断点所接收的异常，是接收“Throw”语句抛出的异常还是Catch语句的
<strong>Action</strong>
和上面出现的一样，都是断点生效后的操作。
<strong>Options</strong>
自动执行action，不中断。</p>

<h3 id="符号断点">符号断点</h3>

<p><img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/20190321162159.png?token=ANanyjTfR8eUG_3EpIkHX-mHMnGbL-E-ks5ck0nowA%3D%3D" alt="" /></p>

<p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项。</p>

<p><strong>Symbol</strong>
他用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）</p>

<p><strong>Module</strong>
用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>

<p>设定一个场景，你想知道对任何controller调用viewdidload方法。那么我们设定断点-[uiviewcontroller viewdidload]
<img src="https://raw.githubusercontent.com/Z-figaro/picBed/master/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-21%20%E4%B8%8B%E5%8D%884.27.09.png?token=ANanygjOO8xPaVVOynZ69RXCrF3-80JVks5ck0vcwA%3D%3D" alt="" /></p>

<p>然后系统会显示所有使用该方法的地方加上断点。</p>

<p>这样如果换成你自己写的方法，那么你可以很轻松的找到使用了该方法的地方；都会停顿。如此排查一些公共组件，或者陌生的方法会非常轻松。</p>

<h2 id="opengl-es-error-breakpoint">OpenGL ES Error Breakpoint</h2>

<p>这个是调试OpenGL ES的断点调试，个人没用到过。</p>

<h2 id="constraint-error">constraint error</h2>

<p>这个是约束错误断点调试，凡是出现约束错误就会执行这个。</p>

<h2 id="总结">总结：</h2>

<p>各种xcode的调试技巧</p>
]]></content>
		</item>
		
		<item>
			<title>Flutter基础</title>
			<link>https://z-figaro.github.io/posts/flutter%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Thu, 07 Mar 2019 10:51:14 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/flutter%E5%9F%BA%E7%A1%80/</guid>
			<description>Flutter是什么？ Flutter是Google一个新的用于构建跨平台的手机App的SDK。写一份代码，在Android 和iOS平台上都可</description>
			<content type="html"><![CDATA[

<h1 id="flutter是什么">Flutter是什么？</h1>

<p>Flutter是Google一个新的用于构建跨平台的手机App的SDK。写一份代码，在Android 和iOS平台上都可以运行。</p>

<h2 id="flutter安装">Flutter安装</h2>

<p>因为我是使用的mac，所以用mac演示</p>

<p>这里是<a href="https://flutter.dev/docs/get-started/install/macos" target="_blank">官方链接</a>，演示了flutter的安装流程，中间有点小坑；我重新走一遍。</p>

<p>1.下载Flutter SDK的最新稳定版本，<a href="https://flutter.dev/docs/development/tools/sdk/archive" target="_blank">地址</a></p>

<p>2.在你的finder选择你想把Flutter工具放的位置，这点和golang要设置gopath非常像。
比如我喜欢放在文稿里：</p>

<pre><code>cd /Users/figaro/Documents/flutter
unzip ~/Downloads/flutter_macos_v1.2.1-stable.zip
</code></pre>

<p>3.将工具添加到路径：</p>

<pre><code>export PATH=&quot;$PATH:`pwd`/flutter/bin&quot;
</code></pre>

<p>这个是临时性方案，这样做只能在当前命令行窗口执行。如果要永久性的话，走下面流程：
3.1 终端进入当前用户的home目录</p>

<pre><code>cd ~
</code></pre>

<p>3.2 创建或者打开profile文件</p>

<pre><code>创建
touch .bash_profile 
打开编辑
open -e .bash_profile 
</code></pre>

<p>编辑完成关闭就保存修改</p>

<p>3.3 更新配置的环境变量</p>

<pre><code>source .bash_profile
</code></pre>

<p>3.4 检查</p>

<pre><code>echo $PATH
</code></pre>

<p>4.检查是否需要依赖完成设置</p>

<pre><code>flutter doctor
</code></pre>

<p>仔细完成提示的解决方案就好：</p>

<pre><code>[!] iOS toolchain - develop for iOS devices
    ✗ Xcode installation is incomplete; a full installation is necessary for iOS
      development.
      Download at: https://developer.apple.com/xcode/download/
      Or install Xcode via the App Store.
      Once installed, run:
        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer
    ✗ libimobiledevice and ideviceinstaller are not installed. To install with
      Brew, run:
        brew update
        brew install --HEAD usbmuxd
        brew link usbmuxd
        brew install --HEAD libimobiledevice
        brew install ideviceinstaller
    ✗ ios-deploy not installed. To install:
        brew install ios-deploy
[!] Android Studio (not installed)
[!] Connected device
    ! No devices available

! Doctor found issues in 4 categories.
</code></pre>

<p>4.1 出现错误解决方案
在这一步：brew install &ndash;HEAD libimobiledevice 出现错误如下：</p>

<pre><code>Error: An unexpected error occurred during the `brew link` step
The formula built, but is not symlinked into /usr/local
Permission denied @ dir_s_mkdir - /usr/local/Frameworks
Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks
</code></pre>

<p>解决方法：</p>

<pre><code> sudo mkdir /usr/local/Frameworks
 sudo chown $(whoami):admin /usr/local/Frameworks
</code></pre>

<p>手机创建目录，然后赋权。可以使用brew cleanup清理废弃文件。</p>

<p>5.xcode配置</p>

<p>xcode9.0以上版本确定有了之后，执行</p>

<pre><code> sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer
</code></pre>

<p>确保通过打开过一次xcode，然后执行</p>

<pre><code>sudo xcodebuild -license
</code></pre>

<p>读完以后按空格，出现以下选择</p>

<p>填写agree</p>

<pre><code>By typing 'agree' you are agreeing to the terms of the software license agreements. Type 'print' to print them or anything else to cancel, [agree, print, cancel] agree
</code></pre>

<p>这样xcode的协议就签署完成。</p>

<p>6.设置iOS模拟器</p>

<p>6.1 打开模拟器</p>

<pre><code> open -a Simulator
</code></pre>

<p>6.2 配置或者不需要修改</p>

<p>通过检查模拟器的硬件&gt;设备菜单中的设置，确保您的模拟器使用的是64位设备（iPhone 5s或更高版本）。
根据您的开发机器的屏幕尺寸，模拟的高屏密度iOS设备可能会溢出您的屏幕。在模拟器的“ 窗口”&gt;“比例”菜单下设置设备比例。</p>

<p>7 创建并运行一个简单的flutter app</p>

<p>7.1 命令行创建一个新的flutter app</p>

<pre><code>flutter create my_app
</code></pre>

<p>7.2 进入此目录</p>

<pre><code>cd my_app
</code></pre>

<p>7.3 要在模拟器中启动应用程序，请确保模拟器<strong>正在运行</strong>并输入：</p>

<pre><code>flutter run
</code></pre>

<p>8 部署到iOS设备</p>

<p>要将Flutter应用程序部署到物理iOS设备，您需要一些其他工具和Apple帐户。您还需要在Xcode中设置物理设备部署。</p>

<p>8.1 确保homebrew 是最新的</p>

<pre><code> brew update
</code></pre>

<p>8.2 通过运行以下命令，安装用于将Flutter应用程序部署到iOS设备的工具</p>

<pre><code> brew install --HEAD usbmuxd
 brew link usbmuxd
 brew install --HEAD libimobiledevice
 brew install ideviceinstaller ios-deploy cocoapods
 pod setup
</code></pre>

<p>iOS的部分基本到这里，如果只是能在apple上使用还说什么跨平台，我们接着设置安卓的部分。</p>

<p>9 android设置</p>

<p>9.1 下载并安装Android studio，<a href="https://developer.android.com/studio" target="_blank">地址</a></p>

<p>9.2 启动Android Studio，然后浏览“Android Studio安装向导”。这将安装最新的Android SDK，Android SDK Platform-Tools和Android SDK Build-Tools，这些都是Flutter在开发Android时所需要的</p>

<p>9.3 设置安卓模拟器</p>

<p>TODO：搞定模拟器</p>

<p>9.4 设置安卓设备</p>

<p>因为我没有安卓设备，我抄的官网的；虽然我很多都是抄的官网的。</p>

<p>要准备在Android设备上运行和测试Flutter应用，您需要一台运行Android 4.1（API级别16）或更高版本的Android设备。</p>

<p>在您的设备上启用开发人员选项和USB调试。Android文档中提供了详细说明。
仅限Windows：安装Google USB驱动程序
使用USB线将手机插入计算机。如果您的设备出现提示，请授权您的计算机访问您的设备。
在终端中，运行flutter devices命令以验证Flutter是否识别您连接的Android设备。
默认情况下，Flutter使用您的adb工具所基于的Android SDK版本。如果您希望Flutter使用Android SDK的其他安装，则必须将 ANDROID_HOME环境变量设置为该安装目录。</p>
]]></content>
		</item>
		
		<item>
			<title>超级账本</title>
			<link>https://z-figaro.github.io/posts/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/</link>
			<pubDate>Tue, 05 Mar 2019 09:57:49 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/</guid>
			<description>Hyperledge Fabric Hyperledger Fabric 是什么？ 它是一个区块链底层平台，提供分布式账本解决方案的平台。 2015年，linux基金会启动了hyperledger项目，目标是发</description>
			<content type="html"><![CDATA[

<h1 id="hyperledge-fabric">Hyperledge Fabric</h1>

<h2 id="hyperledger-fabric-是什么">Hyperledger Fabric 是什么？</h2>

<p>它是一个区块链底层平台，提供分布式账本解决方案的平台。</p>

<p>2015年，linux基金会启动了hyperledger项目，目标是发展跨行业的区块链技术。fabric是Hyperledger中的一个区块链项目。和其他区块链系统相同在于，一样包含一个账本，使用智能合约并且是一个通过所有参与者管理交易的系统，不同点在于私有和许可。fabric通过Membership Service Provider（MSP）来登记所有的成员，通过建立channel来区分不同参与者的账本。</p>

<p>fabric是一个非常商业性质的区块链平台，不能支撑过多的节点。并且对参与者比较有要求。</p>

<h2 id="fabric的模型">fabric的模型</h2>

<p>Assets资产 - 资产定义可以通过网络交换几乎任何具有货币价值的东西，从整个食品到古董车到货币期货。</p>

<p>Chaincode - Chaincode执行与事务排序分开，限制了跨节点类型所需的信任和验证级别，并优化了网络可扩展性和性能。</p>

<p>Ledger Features分类帐功能 - 不可变的共享分类帐为每个通道编码整个事务历史记录，并包括类似SQL的查询功能，以便进行有效的审计和争议解决。</p>

<p>Privacy隐私 - 渠道和私人数据收集实现了私人和机密的多边交易，这些交易通常是在共同网络上交换资产的竞争企业和受监管行业所要求的。</p>

<p>Security &amp; Membership Services安全和会员服务 - 允许的会员资格提供可信的区块链网络，参与者知道所有交易都可以由授权的监管机构和审计员检测和跟踪。</p>

<p>Consensus共识 - 达成共识的独特方法可实现企业所需的灵活性和可扩展性。</p>
]]></content>
		</item>
		
		<item>
			<title>区块链中的联盟链</title>
			<link>https://z-figaro.github.io/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E8%81%94%E7%9B%9F%E9%93%BE/</link>
			<pubDate>Wed, 19 Dec 2018 15:41:38 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E8%81%94%E7%9B%9F%E9%93%BE/</guid>
			<description>联盟链是： 1.公共区块链（Public blockchains） 公共区块链是指全世界任何人都可读取的、任何人都能发送交易且交易能获得有效确认的</description>
			<content type="html"><![CDATA[

<h2 id="联盟链是">联盟链是：</h2>

<p>1.公共区块链（Public blockchains）</p>

<blockquote>
<p>公共区块链是指全世界任何人都可读取的、任何人都能发送交易且交易能获得有效确认的、任何人都能参与其中共识过程的区块链——共识过程决定哪个区块可被添加到区块链中和明确当前状态。作为中心化或者准中心化信任的替代物，公共区块链的安全由“加密数字经济”维护——“加密数字经济”采取工作量证明机制或权益证明机制等方式，将经济奖励和加密数字验证结合了起来，并遵循着一般原则：每个人从中可获得的经济奖励，与对共识过程作出的贡献成正比。这些区块链通常被认为是“完全去中心化”的。</p>
</blockquote>

<p>2.联盟区块链：（Consortium blockchains）</p>

<blockquote>
<p>联盟区块链是指其共识过程受到预选节点控制的区块链；例如，不妨想象一个有15个金融机构组成的共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认（2/3确认）。区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型路线，例如区块的根哈希及其API（应用程序接口）对外公开，API可允许外界用来作有限次数的查询和获取区块链状态的信息。这些区块链可视为“部分去中心化”。</p>
</blockquote>

<p>3.完全私有区块链（Fully private blockchains）</p>

<blockquote>
<p>完全私有的区块链是指其写入权限仅在一个组织手里的区块链。读取权限或者对外开放，或者被任意程度地进行了限制。相关的应用囊括数据库管理、审计、甚至一个公司，尽管在有些情况下希望它能有公共的可审计性，但在很多的情形下，公共的可读性并非是必须的。</p>
</blockquote>

<p>——Vitalik Buterin（以太坊创始人）谈Private vs Public</p>

<p>以上是V神理解的区块链细分区别，因为工作的原因，我三种链都接触了。首先，任何流程化和需要审核和信任的过程都可以用区块链技术；所以未来区块链技术会是一份像今天开发web页面一样的基本技术。未来必定会有浩如星海的私链，错综复杂的联盟链；加上部分地区，国家基本的共链。这些链把我们所有人的生活都数字化。</p>

<p>联盟链未来一定是企业标配，现在还做不到，只是技术和成本门槛。Linux基金会其中的开源项目fabric，提供了开发基础框架；如果未来能够突破100个节点这样的限制条件，潜力无限。</p>

<p>联盟链一定会经历根据业务特点，形成很多不能兼容和效率低下的问题。最好的解决办法就是开发一条侧链来辅助各公司甚至各个业务层来完成具体的工作。这样会成为一个轻客户端的彻底解决方案，不过开发侧链又会是一个专门的部分，人力物力会和中心化的微服务中台比较上；会有一部分的提高。但是对于有一定规模的公司，这就不是一个问题。</p>

<p><img src="https://lh3.googleusercontent.com/-xmnkNzfEfv4/XBr5INjeakI/AAAAAAAAB6Y/QiqIcoGfi28MqjKLsIamtS9cob93EEWRgCHMYCw/I/%255BUNSET%255D" alt="屏幕快照 2018-12-20 上午10.03.24" /></p>

<h2 id="联盟链和多链架构的价值">联盟链和多链架构的价值</h2>

<ul>
<li>协作灵活</li>
<li>可编程资产打通联盟链条</li>
<li>利益分配公平公正</li>
</ul>

<p>所有的价值，其实都是根据业务场景和需求来定义的。所有伟大的创造，都是根据这样的方式来演进。</p>

<p>基金链：Lp，Gp，Cp这三个主要角色，甚至加上vc，监管方，银行。这些所有是否都应该用去中心的技术方案呢？</p>

<p>联盟链一定是先线下共识达成之后，才能够上链。</p>
]]></content>
		</item>
		
		<item>
			<title>Python基础</title>
			<link>https://z-figaro.github.io/posts/python%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Wed, 19 Dec 2018 15:40:38 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/python%E5%9F%BA%E7%A1%80/</guid>
			<description>&lt;p&gt;慢慢积累所有的基础知识，有深入的使用或者了解。会在后面单开章节写。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>慢慢积累所有的基础知识，有深入的使用或者了解。会在后面单开章节写。</p>

<h1 id="import-与-from-import">import 与 from&hellip;import</h1>

<p>在 python 用 import 或者 from&hellip;import 来导入相应的模块。</p>

<p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p>

<p>从某个模块中导入某个函数,格式为：** from somemodule import somefunction**</p>

<p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p>

<p>将某个模块中的全部函数导入，格式为： **from somemodule import ***</p>

<h1 id="标准数据类型">标准数据类型</h1>

<p>Python3 中有六个标准的数据类型：</p>

<ol>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ol>

<p>Python3 的六个标准数据类型中：</p>

<p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>

<h2 id="number">Number</h2>

<p>Python3 支持 int、float、bool、complex（复数）。</p>

<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>

<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>

<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>

<pre><code>  a, b, c, d = 20, 5.5, True, 4+3j
  print(type(a), type(b), type(c), type(d))
  &lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt;
</code></pre>

<h3 id="计算">计算</h3>

<pre><code>a = 11
b =  5

c = a + b

# 加减乘除
print (a + b)
print (a - b)
print (a * b)
print (a / b) 除，得到一个浮点数
print (a // b) 除，得到一个整数
print (a % b) 取余数
print (a ** b) 乘方

16
6
55
2.2
2
1
161051
</code></pre>

<h2 id="字符串">字符串</h2>

<pre><code>str = 'Runoob'
 
print (str)          # 输出字符串
print (str[0:-1])    # 输出第一个到倒数第二个的所有字符
print (str[0])       # 输出字符串第一个字符
print (str[2:5])     # 输出从第三个开始到第五个的字符
print (str[2:])      # 输出从第三个开始的后的所有字符
print (str * 2)      # 输出字符串两次
print (str + &quot;TEST&quot;) # 连接字符串
</code></pre>

<p>结果：</p>

<pre><code>Runoob
Runoo
R
noo
noob
RunoobRunoob
RunoobTEST
</code></pre>

<h4 id="注意">注意：</h4>

<p>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。
2、字符串可以用+运算符连接在一起，用*运算符重复。
3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。
4、Python中的字符串不能改变。</p>

<h2 id="list-列表">List 列表</h2>

<p>List（列表） 是 Python 中使用最频繁的数据类型，完全就是oc中的可变数组。</p>

<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>

<p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p>

<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>

<pre><code>list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]
tinylist = [123, 'runoob']
 
print (list)            # 输出完整列表
print (list[0])         # 输出列表第一个元素
print (list[1:3])       # 从第二个开始输出到第三个元素
print (list[2:])        # 输出从第三个元素开始的所有元素
print (tinylist * 2)    # 输出两次列表
print (list + tinylist) # 连接列表
</code></pre>

<p>结果：</p>

<pre><code>['abcd', 786, 2.23, 'runoob', 70.2]
abcd
[786, 2.23]
[2.23, 'runoob', 70.2]
[123, 'runoob', 123, 'runoob']
['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']
</code></pre>

<h2 id="tuple-元组">tuple 元组</h2>

<p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p>

<pre><code>tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
tinytuple = (123, 'runoob')
 
print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
</code></pre>

<p>结果：</p>

<pre><code>('abcd', 786, 2.23, 'runoob', 70.2)
abcd
(786, 2.23)
(2.23, 'runoob', 70.2)
(123, 'runoob', 123, 'runoob')
('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')
</code></pre>

<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>

<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>

<pre><code>tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
</code></pre>

<h2 id="set-集合">Set（集合）</h2>

<p>集合（set）是一个无序不重复元素的序列。</p>

<p>基本功能是进行成员关系测试和删除重复元素。</p>

<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>

<p>创建格式：</p>

<pre><code>parame = {value01,value02,...}
或者
set(value)
</code></pre>

<h2 id="dictionary-字典">Dictionary（字典）</h2>

<p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>

<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>

<p>字典是一种映射类型，字典用&rdquo;{ }&ldquo;标识，它是一个无序的键(key) : 值(value)对集合。</p>

<p>键(key)必须使用不可变类型。</p>

<p>在同一个字典中，键(key)必须是唯一的。</p>

<pre><code>dict = {}
dict['one'] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;
 
tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}
 
 
print (dict['one'])       # 输出键为 'one' 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre>

<p>结果：</p>

<pre><code>1 - 菜鸟教程
2 - 菜鸟工具
{'name': 'runoob', 'site': 'www.runoob.com', 'code': 1}
dict_keys(['name', 'site', 'code'])
dict_values(['runoob', 'www.runoob.com', 1])
</code></pre>

<h2 id="数据类型转换">数据类型转换</h2>

<pre><code>int(x [,base])

将x转换为一个整数

float(x)

将x转换到一个浮点数

complex(real [,imag])

创建一个复数

str(x)

将对象 x 转换为字符串

repr(x)

将对象 x 转换为表达式字符串

eval(str)

用来计算在字符串中的有效Python表达式,并返回一个对象

tuple(s)

将序列 s 转换为一个元组

list(s)

将序列 s 转换为一个列表

set(s)

转换为可变集合

dict(d)

创建一个字典。d 必须是一个序列 (key,value)元组。

frozenset(s)

转换为不可变集合

chr(x)

将一个整数转换为一个字符

ord(x)

将一个字符转换为它的整数值

hex(x)

将一个整数转换为一个十六进制字符串

oct(x)

将一个整数转换为一个八进制字符串
</code></pre>

<h2 id="数据运算">数据运算</h2>

<p>赋值运算符：
这个和ios很不一样</p>

<pre><code>=	简单的赋值运算符	c = a + b 将 a + b 的运算结果赋值为 c
+=	加法赋值运算符	c += a 等效于 c = c + a
-=	减法赋值运算符	c -= a 等效于 c = c - a
*=	乘法赋值运算符	c *= a 等效于 c = c * a
/=	除法赋值运算符	c /= a 等效于 c = c / a
%=	取模赋值运算符	c %= a 等效于 c = c % a
**=	幂赋值运算符	c **= a 等效于 c = c ** a
//=	取整除赋值运算符	c //= a 等效于 c = c // a
</code></pre>

<p>逻辑运算符</p>

<pre><code>and	x and y	布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。	(a and b) 返回 20。
or	x or y	布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。	(a or b) 返回 10。
not	not x	布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。	not(a and b) 返回 False
</code></pre>

<p>成员运算符</p>

<pre><code>in	如果在指定的序列中找到值返回 True，否则返回 False。	x 在 y 序列中 , 如果 x 在 y 序列中返回 True。
not in	如果在指定的序列中没有找到值返回 True，否则返回 False。	x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。
</code></pre>

<p>身份运算符</p>

<pre><code>is	is 是判断两个标识符是不是引用自一个对象	x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False
is not	is not 是判断两个标识符是不是引用自不同对象	x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。
</code></pre>

<p><strong><em>is 与 == 区别：</em></strong></p>

<p>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</p>

<p>运算优先级从高到低：</p>

<pre><code>**	指数 (最高优先级)
~ + -	按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
* / % //	乘，除，取模和取整除
+ -	加法减法
&gt;&gt; &lt;&lt;	右移，左移运算符
&amp;	位 'AND'
^ |	位运算符
&lt;= &lt; &gt; &gt;=	比较运算符
&lt;&gt; == !=	等于运算符
= %= /= //= -= += *= **=	赋值运算符
is is not	身份运算符
in not in	成员运算符
and or not	逻辑运算符
</code></pre>

<h3 id="tips">tips：</h3>

<p>ype 是用于求一个未知数据类型对象，而 isinstance 是用于判断一个对象是否是已知类型。</p>

<p>type 不认为子类是父类的一种类型，而isinstance会认为子类是父类的一种类型。</p>

<p>可以用 isinstance 判断子类对象是否继承于父类，type 不行。</p>

<p>综合以上几点，type 与 isinstance 虽然都与数据类型相关，但两者其实用法不同，type 主要用于判断未知数据类型，isinstance 主要用于判断 A 类是否继承于 B 类：</p>]]></content>
		</item>
		
		<item>
			<title>ARKit总结</title>
			<link>https://z-figaro.github.io/posts/arkit%E6%80%BB%E7%BB%93/</link>
			<pubDate>Wed, 19 Dec 2018 15:40:19 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/arkit%E6%80%BB%E7%BB%93/</guid>
			<description>ARkit是什么？ ARKit是WWDC 17中公开的系统库，可以提供增强现实的体验。 ARKit的工作原理： 1.相机捕捉现实景象---由ARKi</description>
			<content type="html"><![CDATA[

<h1 id="arkit是什么">ARkit是什么？</h1>

<pre><code>ARKit是WWDC 17中公开的系统库，可以提供增强现实的体验。
</code></pre>

<h2 id="arkit的工作原理">ARKit的工作原理：</h2>

<pre><code>1.相机捕捉现实景象---由ARKit实现
2.在现实景象中显示2d/3d虚拟图像--scenneKit对应3d实现，spriteKit实现2d
</code></pre>

<p><img src="https://lh3.googleusercontent.com/-ZqTZUBgF1ig/W8f4EGb3-GI/AAAAAAAAB5s/ja-zOUSGE1QDrqLKA0cuYIAnUr5m1vi9ACHMYCw/I/arkit.png" alt="arkit" /></p>

<h3 id="arscnview">ARscnview</h3>

<p>用于显示3d虚拟的视图
作用：管理一个ARsession，一个arscnview实例默认持有一个arsession。</p>

<h3 id="arsession">ARsession</h3>

<p>ARSession主要用于协调在构建增强现实体验的过程中各个关键步骤，如读取传感器数据，控制相机，分析图片等。</p>

<h3 id="arconfiguration">ARconfiguration</h3>

<p>ARWorldTrackingConfiguration：跟踪设备的位置、方向、平面检测和hit testing。
AROrientationTrackingConfiguration：仅用于方向跟踪。
ARFaceTrackingConfiguration：前置摄像头仅用于人脸跟踪。</p>

<h3 id="arframe">ARframe</h3>

<p>相机的位置数据，实质就是各种位置数据</p>

<p>配合ARSession使用（currentFrame属性）,ARSession不停的获取视频帧信息，并结合底层的传感器信息，将处理好的跟踪信息和图像参数放到这个类中。</p>
]]></content>
		</item>
		
		<item>
			<title>区块链是什么？</title>
			<link>https://z-figaro.github.io/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88/</link>
			<pubDate>Wed, 19 Dec 2018 15:38:42 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
			<description>&lt;h1 id=&#34;区块链&#34;&gt;区块链&lt;/h1&gt;

&lt;h2 id=&#34;区块链到底是什么&#34;&gt;区块链到底是什么？&lt;/h2&gt;

&lt;p&gt;区块链技术设计之初是为了解决不需要任何机构，组织来背书，大家就可以对某件事，某个规则，某个事物的价值和意义达成一种共识；遵守就可以得到正反馈，不遵守又想得到正反馈的任何行为都被设计的这一套区块链技术所防止。这就是我理解的区块链技术。近代以来的伟大技术好像都是这样为了理想诞生的，git之父Linus Torvalds（同样也是linux之父，发现为什么叫linux了。）为了不想和别人一起上班，不想天天面对别人，所以发明了git来管理代码。。。。。任性啊。所以区块链技术不是为了发币，发币只是提供正反馈的一种抽象机制；毕竟数字最容易提现。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<h1 id="区块链">区块链</h1>

<h2 id="区块链到底是什么">区块链到底是什么？</h2>

<p>区块链技术设计之初是为了解决不需要任何机构，组织来背书，大家就可以对某件事，某个规则，某个事物的价值和意义达成一种共识；遵守就可以得到正反馈，不遵守又想得到正反馈的任何行为都被设计的这一套区块链技术所防止。这就是我理解的区块链技术。近代以来的伟大技术好像都是这样为了理想诞生的，git之父Linus Torvalds（同样也是linux之父，发现为什么叫linux了。）为了不想和别人一起上班，不想天天面对别人，所以发明了git来管理代码。。。。。任性啊。所以区块链技术不是为了发币，发币只是提供正反馈的一种抽象机制；毕竟数字最容易提现。</p>

<p>区块链技术现在被传播的定义是：去中心化的分布式账本数据库。
  在一定时间段内有任何数据变化，系统中每个节点都可以来进行记录，系统会评判出最先最准确完成记录的节点，并将其记录“打包”成一个“数据区块”发送给其他节点。其他节点验证区块中各项信息无误后，所有节点同步将这个新产生的区块保存下来，并与之前产生的区块链进行连接，形成一条最新的数据记录链条。即：系统中每个节点都有一份完整的数据记录。一个区块包含两个部分：区块头(BlockHeader)和数据变动部分。区块记录的所有数据变动通过默克尔树(MerkleTree)组织起来，默克尔树根(Root)的哈希值作为本区块里所有交易的信息被放入区块头。区块头还包含以下字段：前一个区块头的哈希值（或称哈希指针）、本区块的时间戳、高度(从第一个区块开始数，本区块是第几个块)以及其他信息。新的区块在经过系统共识验证后被添加到区块链上。因为任何输入端的细微变化都会对哈希函数的输出结果产生较大影响，再加上哈希指针的设计，所以通过区块链记录的数据通常难以篡改。比如，若有人尝试改写1号区块里的数据，那么存储在2号区块里的1号区块的哈希值将会产生巨大的变化，从而导致2号区块的哈希值随之发生变化，接着又影响存储在3号区块的2号区块的哈希值，以此类推，后续的所有区块数据都会发生变化。</p>

<p>1.0：BTC
2.0：ETH
3.0：IPFS这样的具体应用</p>]]></content>
		</item>
		
		<item>
			<title>Go语言基础</title>
			<link>https://z-figaro.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</link>
			<pubDate>Wed, 19 Dec 2018 15:38:14 +0800</pubDate>
			
			<guid>https://z-figaro.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</guid>
			<description>&lt;p&gt;go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。&lt;/p&gt;</description>
			<content type="html"><![CDATA[<p>go 的所有基础知识，根据自己的情况，不定时添加。更深入的内容会单开文章来写。</p>

<h1 id="go语言基础">go语言基础</h1>

<h2 id="go语言特性">GO语言特性</h2>

<p>1.不用做内存管理
2.天然支持高并发
3.channel管道
    管道最初是unix中的特性，因为进程之间是隔离的，如果两个进程之间需要资源交互；那么就把资源放到管道中。通过管道交互。
4.多返回值</p>

<h2 id="go-语言的包引入一般为-项目名-包名">Go 语言的包引入一般为: 项目名/包名</h2>

<p><code>import &quot;test/controllers&quot;</code>
方法的调用为: 包名.方法名()</p>

<p><code>controllers.Test()</code>
本包内方法名可为小写，包外调用方法名首字母必须为大写。</p>

<h2 id="fmt包">fmt包</h2>

<p>1.<strong>Print()</strong> 函数将参数列表 a 中的各个参数转换为字符串并写入到标准输出中。</p>

<p>非字符串参数之间会添加空格，返回写入的字节数。</p>

<p><code>func Print(a ...interface{}) (n int, err error)</code></p>

<p>2.<strong>Println()</strong> 函数功能类似 Print，只不过最后会添加一个换行符。</p>

<p>所有参数之间会添加空格，返回写入的字节数。</p>

<p><code>func Println(a ...interface{}) (n int, err error)</code></p>

<p>3.<strong><em>Printf()</em></strong> 函数将参数列表 a 填写到格式字符串 format 的占位符中。</p>

<p>填写后的结果写入到标准输出中，返回写入的字节数。</p>

<p><code>func Printf(format string, a ...interface{}) (n int, err error)</code></p>

<p>实例：</p>

<pre><code>   fmt.Print(&quot;a&quot;, &quot;b&quot;, 1, 2, 3, &quot;c&quot;, &quot;d&quot;, &quot;\n&quot;)
	fmt.Println(&quot;a&quot;, &quot;b&quot;, 1, 2, 3, &quot;c&quot;, &quot;d&quot;)
	fmt.Printf(&quot;ab %d %d %d cd\n&quot;, 1, 2, 3)
	fmt.Println(&quot;你好&quot;)
	
    ab1 2 3cd
    a b 1 2 3 c d
    ab 1 2 3 cd
    你好
</code></pre>

<h2 id="条件控制">条件控制</h2>

<ol>
<li>支持多条件匹配</li>
</ol>

<pre><code>switchswitch{{
         casecase  11,,22,,33,,44::
         defaultdefault::
 }}
</code></pre>

<ol>
<li><p>不同的 case 之间不使用 break 分隔，默认只会执行一个 case。</p></li>

<li><p>如果想要执行多个 case，需要使用 fallthrough 关键字，也可用 break 终止。</p></li>
</ol>

<pre><code>switch{
    case 1:
    ...
    if(...){
        break
    }

    fallthrough // 此时switch(1)会执行case1和case2，但是如果满足if条件，则只执行case1

    case 2:
    ...
    case 3:
}
</code></pre>

<h3 id="select-语句">select 语句</h3>

<p>select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。</p>

<p>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p>

<p>以下描述了 select 语句的语法：</p>

<p>每个case都必须是一个通信
所有channel表达式都会被求值
所有被发送的表达式都会被求值
如果任意某个通信可以进行，它就执行；其他被忽略。
如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
否则：
如果有default子句，则执行该语句。
如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = &lt;-c1:
         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)
      case c2 &lt;- i2:
         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)
      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
         if ok {
            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)
         } else {
            fmt.Printf(&quot;c3 is closed\n&quot;)
         }
      default:
         fmt.Printf(&quot;no communication\n&quot;)
   }    
}
</code></pre>

<h2 id="函数">函数</h2>

<pre><code>func function_name( [parameter list] ) [return_types] {
   函数体
}
</code></pre>

<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200
   var ret int

   /* 调用函数并返回最大值 */
   ret = max(a, b)

   fmt.Printf( &quot;最大值是 : %d\n&quot;, ret )
}

/* 函数返回两个数的最大值 */
func max(num1, num2 int) int {
   /* 定义局部变量 */
   var result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</code></pre>

<h2 id="全局变量与局部变量">全局变量与局部变量</h2>

<p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p>

<pre><code>package main

import &quot;fmt&quot;

/* 声明全局变量 */
var g int = 20

func main() {
   /* 声明局部变量 */
   var g int = 10

   fmt.Printf (&quot;结果： g = %d\n&quot;,  g)
}
</code></pre>

<p>一个更好的实例：</p>

<pre><code>package main

import &quot;fmt&quot;

/* 声明全局变量 */
var a int = 20

func main() {
    /* main 函数中声明局部变量 */
    var a int = 10
    var b int = 20
    var c int = 0

    fmt.Printf(&quot;main()函数中 a = %d\n&quot;, a)
    c = sum(a, b)
    fmt.Printf(&quot;main()函数中 a = %d\n&quot;, a)
    fmt.Printf(&quot;main()函数中 c = %d\n&quot;, c)
}

/* 函数定义-两数相加 */
func sum(a, b int) int {
    a = a + 1
    fmt.Printf(&quot;sum() 函数中 a = %d\n&quot;, a)
    fmt.Printf(&quot;sum() 函数中 b = %d\n&quot;, b)
    return a + b
}
</code></pre>

<p>结果：</p>

<pre><code>main()函数中 a = 10
sum() 函数中 a = 11
sum() 函数中 b = 20
main()函数中 a = 10
main()函数中 c = 31
</code></pre>

<h2 id="切片">切片</h2>

<p>Go 语言切片是对数组的抽象。</p>

<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(&ldquo;动态数组&rdquo;),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>

<p>定义：
<code>var identifier []type</code></p>

<p>简写：
&gt; var slice1 []type = make([]type, len)</p>

<blockquote>
<p>也可以简写为</p>

<p>slice1 := make([]type, len)</p>
</blockquote>

<p>也可以指定容量，其中capacity为可选参数。
&gt; make([]T, length, capacity)</p>

<h3 id="切片初始化">切片初始化</h3>

<blockquote>
<p>s :=[] int {1,2,3 }
直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p>

<p>s := arr[:]
初始化切片s,是数组arr的引用</p>

<p>s := arr[startIndex:endIndex]
将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p>

<p>s := arr[startIndex:]
缺省endIndex时将表示一直到arr的最后一个元素</p>

<p>s := arr[:endIndex]
缺省startIndex时将表示从arr的第一个元素开始</p>

<p>s1 := s[startIndex:endIndex]
通过切片s初始化切片s1</p>

<p>s :=make([]int,len,cap)
通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p>
</blockquote>

<h3 id="len-和-cap-函数">len() 和 cap() 函数</h3>

<p>切片是可索引的，并且可以由 len() 方法获取长度。</p>

<p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var numbers = make([]int,3,5)

   printSlice(numbers)
}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=3 cap=5 slice=[0 0 0]
</code></pre>

<h3 id="切片截取">切片截取</h3>

<p>可以通过设置下限及上限来设置截取切片 [lower-bound:upper-bound]，实例如下</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   /* 创建切片 */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)

   /* 打印原始切片 */
   fmt.Println(&quot;numbers ==&quot;, numbers)

   /* 打印子切片从索引1(包含) 到索引4(不包含)*/
   fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4])

   /* 默认下限为 0*/
   fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3])

   /* 默认上限为 len(s)*/
   fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:])

   numbers1 := make([]int,0,5)
   printSlice(numbers1)

   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */
   number2 := numbers[:2]
   printSlice(number2)

   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */
   number3 := numbers[2:5]
   printSlice(number3)

}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]
numbers == [0 1 2 3 4 5 6 7 8]
numbers[1:4] == [1 2 3]
numbers[:3] == [0 1 2]
numbers[4:] == [4 5 6 7 8]
len=0 cap=5 slice=[]
len=2 cap=9 slice=[0 1]
len=3 cap=7 slice=[2 3 4]
</code></pre>

<h3 id="append-和-copy-函数">append() 和 copy() 函数</h3>

<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p>

<p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var numbers []int
   printSlice(numbers)

   /* 允许追加空切片 */
   numbers = append(numbers, 0)
   printSlice(numbers)

   /* 向切片添加一个元素 */
   numbers = append(numbers, 1)
   printSlice(numbers)

   /* 同时添加多个元素 */
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)

   /* 创建切片 numbers1 是之前切片的两倍容量*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)

   /* 拷贝 numbers 的内容到 numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)
}

结果：
len=0 cap=0 slice=[]
len=1 cap=1 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=6 slice=[0 1 2 3 4]
len=5 cap=12 slice=[0 1 2 3 4]

</code></pre>

<h3 id="范围range">范围Range</h3>

<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。</p>

<h2 id="map">map</h2>

<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>

<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>

<p>/* 声明变量，默认 map 是 nil */
&gt; var map_variable map[key_data_type]value_data_type</p>

<p>/* 使用 make 函数 */
&gt; map_variable := make(map[key_data_type]value_data_type)</p>

<p><strong>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</strong></p>

<p>实例：</p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    var countryCapitalMap map[string]string /*创建集合 */
    countryCapitalMap = make(map[string]string)

    /* map插入key - value对,各个国家对应的首都 */
    countryCapitalMap [ &quot;France&quot; ] = &quot;Paris&quot;
    countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;
    countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;
    countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;

    /*使用键输出地图值 */ for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])
    }

    /*查看元素在集合中是否存在 */
    captial, ok := countryCapitalMap [ &quot;美国&quot; ] /*如果确定是真实的,则存在,否则不存在 */
    /*fmt.Println(captial) */
    /*fmt.Println(ok) */
    if (ok) {
        fmt.Println(&quot;美国的首都是&quot;, captial)
    } else {
        fmt.Println(&quot;美国的首都不存在&quot;)
    }
}

结果：
France 首都是 Paris
Italy 首都是 罗马
Japan 首都是 东京
India  首都是 新德里
美国的首都不存在
</code></pre>

<h3 id="delete-函数">delete() 函数</h3>

<pre><code>package main

import &quot;fmt&quot;

func main() {
    /* 创建map */
    countryCapitalMap := map[string]string{&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;}

    fmt.Println(&quot;原始地图&quot;)

    /* 打印地图 */
    for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])
    }

    /*删除元素*/ delete(countryCapitalMap, &quot;France&quot;)
    fmt.Println(&quot;法国条目被删除&quot;)

    fmt.Println(&quot;删除元素后地图&quot;)

    /*打印地图*/
    for country := range countryCapitalMap {
        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])
    }
}

结果：
原始地图
India 首都是 New delhi
France 首都是 Paris
Italy 首都是 Rome
Japan 首都是 Tokyo
法国条目被删除
删除元素后地图
Italy 首都是 Rome
Japan 首都是 Tokyo
India 首都是 New delhi
</code></pre>

<h2 id="递归函数">递归函数</h2>

<pre><code>func recursion() {
   recursion() /* 函数调用自身 */
}

func main() {
   recursion()
}
</code></pre>

<p>Go 语言支持递归。但我们在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中。</p>

<p>递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等</p>

<pre><code>package main

import &quot;fmt&quot;

func fibonacci(n int) int {
  if n &lt; 2 {
   return n
  }
  return fibonacci(n-2) + fibonacci(n-1)
}

func main() {
    var i int
    for i = 0; i &lt; 10; i++ {
       fmt.Printf(&quot;%d\t&quot;, fibonacci(i))
    }
}

结果：
0    1    1    2    3    5    8    13    21    34
</code></pre>

<h2 id="类型转换">类型转换</h2>

<blockquote>
<p>type_name(expression)</p>
</blockquote>

<p><strong>type_name 为类型，expression 为表达式。</strong></p>

<pre><code>package main

import &quot;fmt&quot;

func main() {
   var sum int = 17
   var count int = 5
   var mean float32
   
   mean = float32(sum)/float32(count)
   fmt.Printf(&quot;mean 的值为: %f\n&quot;,mean)
}

结果：
mean 的值为: 3.400000
</code></pre>

<h2 id="接口">接口</h2>

<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>

<p>表达：</p>

<pre><code>/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
</code></pre>

<p>实例：</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

type Phone interface {
    call()
}

type NokiaPhone struct {
}

func (nokiaPhone NokiaPhone) call() {
    fmt.Println(&quot;I am Nokia, I can call you!&quot;)
}

type IPhone struct {
}

func (iPhone IPhone) call() {
    fmt.Println(&quot;I am iPhone, I can call you!&quot;)
}

func main() {
    var phone Phone

    phone = new(NokiaPhone)
    phone.call()

    phone = new(IPhone)
    phone.call()

}

在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：

I am Nokia, I can call you!
I am iPhone, I can call you!
</code></pre>

<h2 id="错误处理">错误处理</h2>

<pre><code>type error interface {
    Error() string
}
</code></pre>

<p>这是定义。</p>

<pre><code>package main

import (
    &quot;fmt&quot;
)

// 定义一个 DivideError 结构
type DivideError struct {
    dividee int
    divider int
}

// 实现 `error` 接口
func (de *DivideError) Error() string {
    strFormat := `
    Cannot proceed, the divider is zero.
    dividee: %d
    divider: 0
`
    return fmt.Sprintf(strFormat, de.dividee)
}

// 定义 `int` 类型除法运算的函数
func Divide(varDividee int, varDivider int) (result int, errorMsg string) {
    if varDivider == 0 {
        dData := DivideError{
            dividee: varDividee,
            divider: varDivider,
        }
        errorMsg = dData.Error()
        return
    } else {
        return varDividee / varDivider, &quot;&quot;
    }

}

func main() {

    // 正常情况
    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; {
        fmt.Println(&quot;100/10 = &quot;, result)
    }
    // 当被除数为零的时候会返回错误信息
    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; {
        fmt.Println(&quot;errorMsg is: &quot;, errorMsg)
    }

}

结果：
100/10 =  10
errorMsg is:  
    Cannot proceed, the divider is zero.
    dividee: 100
    divider: 0
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
